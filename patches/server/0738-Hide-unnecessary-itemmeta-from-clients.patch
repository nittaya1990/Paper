From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Noah van der Aa <ndvdaa@gmail.com>
Date: Tue, 3 Aug 2021 17:28:27 +0200
Subject: [PATCH] Hide unnecessary itemmeta from clients.


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index c334f29c69c1e6e3fe55cd6695e7df400cf36058..2f3a66c1b652b059bfb3cf0b421dfe98c9f96204 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -863,6 +863,11 @@ public class PaperWorldConfig {
         behaviorTickRates = loadTickRates("behavior");
     }
 
+    public boolean hideItemmetaFromClients = true;
+    private void getHideItemmetaFromClients() {
+        hideItemmetaFromClients = getBoolean("hide-itemmeta-from-clients", hideItemmetaFromClients);
+    }
+
     private Table<String, String, Integer> loadTickRates(String type) {
         log("  " + type + ":");
         Table<String, String, Integer> table = HashBasedTable.create();
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 2b7eeb5659b1083ef550eb9feb0b7ba8a92a92e3..851fcd3bcfa88839c32e8d708c65279ad419a90f 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3035,12 +3035,81 @@ public abstract class LivingEntity extends Entity {
 
     }
 
+    private static final List<String> shownNBTTags = List.of("CustomModelData", "SkullOwner", "CustomPotionColor", "Potion", "LodestoneTracked", "LodestoneDimension", "LodestonePos", "Charged", "ChargedProjectiles", "Explosion"); // Paper
+
     private void handleEquipmentChanges(Map<EquipmentSlot, ItemStack> equipment) {
         List<Pair<EquipmentSlot, ItemStack>> list = Lists.newArrayListWithCapacity(equipment.size());
 
         equipment.forEach((enumitemslot, itemstack) -> {
             ItemStack itemstack1 = itemstack.copy();
 
+            // Paper start - hide unnecessary itemmeta from clients.
+            if(itemstack1.getTag() != null && this.level.paperConfig.hideItemmetaFromClients) {
+                CompoundTag oldNbt = itemstack1.getTag();
+                itemstack1.setCount(1);
+
+                CompoundTag newNbt = new CompoundTag();
+
+                for (String tag : shownNBTTags) {
+                    if (oldNbt.contains(tag)) {
+                        newNbt.put(tag, oldNbt.get(tag));
+                    }
+                }
+
+                // Colors for leather helmets and maps.
+                if (oldNbt.get("display") instanceof CompoundTag oldDisplay && (oldDisplay.contains("color") || oldDisplay.contains("MapColor"))) {
+                    CompoundTag display = new CompoundTag();
+                    if (oldDisplay.contains("color")) {
+                        display.put("color", oldDisplay.get("color"));
+                    }
+                    if (oldDisplay.contains("MapColor")) {
+                        display.put("MapColor", oldDisplay.get("MapColor"));
+                    }
+                    newNbt.put("display", display);
+                }
+
+                if (oldNbt.get("Enchantments") instanceof ListTag oldEnchantments && !oldEnchantments.isEmpty()) {
+                    // The client still renders items with the enchantment glow if the enchantments tag contains at least one (empty) child.
+                    ListTag enchantments = new ListTag();
+                    enchantments.add(new CompoundTag());
+                    newNbt.put("Enchantments", enchantments);
+                }
+
+                // Light levels for light blocks
+                if (oldNbt.get("BlockStateTag") instanceof CompoundTag oldBlockState && oldBlockState.contains("level")) {
+                    CompoundTag blockState = new CompoundTag();
+                    blockState.put("level", oldBlockState.get("level"));
+                    newNbt.put("BlockStateTag", blockState);
+                }
+
+                // Show broken elytras.
+                int damage = 0;
+                if (itemstack1.is(Items.ELYTRA) && itemstack1.getDamageValue() >= itemstack1.getMaxDamage() - 1) {
+                    damage = itemstack1.getDamageValue();
+                }
+
+                // Bundles change their texture based on their fullness.
+                if (itemstack1.is(Items.BUNDLE) && oldNbt.get("Items") instanceof ListTag oldItems && !oldItems.isEmpty())  {
+                    org.bukkit.inventory.meta.BundleMeta bundleMeta = (org.bukkit.inventory.meta.BundleMeta) itemstack1.asBukkitMirror().getItemMeta();
+                    int sizeUsed = 0;
+                    for (org.bukkit.inventory.ItemStack item : bundleMeta.getItems()){
+                        int scale = 64 / item.getMaxStackSize();
+                        sizeUsed += scale * item.getAmount();
+                    }
+                    // Now we add a single fake item that uses the same amount of slots as all other items.
+                    ListTag items = new ListTag();
+                    CompoundTag fakeItem = new CompoundTag();
+                    fakeItem.putInt("Count", sizeUsed);
+                    fakeItem.putString("id", "minecraft:paper");
+                    items.add(fakeItem);
+                    newNbt.put("Items", items);
+                }
+
+                itemstack1.setTag(newNbt);
+                itemstack1.setDamageValue(damage);
+            }
+            // Paper end.
+
             list.add(Pair.of(enumitemslot, itemstack1));
             switch (enumitemslot.getType()) {
                 case HAND:
